# .github/workflows/llm-accessibility-fixer.yml
name: LLM + A11y MCP Accessibility Fixer

on:
  push:
    branches: [main, master]
  
  pull_request:
    branches: [main, master]
  
  workflow_dispatch:
    inputs:
      force_fix:
        description: 'Force fixes even if no issues detected'
        required: false
        default: false
        type: boolean

jobs:
  fix-accessibility:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create package.json
        run: |
          cat > package.json << 'EOF'
          {
            "name": "llm-a11y-fixer",
            "version": "1.0.0",
            "type": "module",
            "dependencies": {
              "@modelcontextprotocol/sdk": "^0.5.0",
              "openai": "^4.0.0"
            }
          }
          EOF

      - name: Install dependencies
        run: |
          npm install
          npm install -g a11y-mcp-server
          echo "‚úÖ Dependencies installed"

      - name: Validate environment
        run: |
          if [ -z "${{ secrets.OPENAI_API_KEY }}" ]; then
            echo "‚ùå OPENAI_API_KEY secret is required"
            exit 1
          fi
          echo "‚úÖ Environment validated"

      - name: Backup HTML files
        run: |
          echo "üíæ Creating backups..."
          find . -name "*.html" -not -path "./.git/*" -not -path "./node_modules/*" | while read file; do
            cp "$file" "$file.original"
            echo "Backed up: $file"
          done

      - name: Create the accessibility fixer script
        run: |
          mkdir -p .github/scripts
          cat > .github/scripts/llm-accessibility-fixer.js << 'SCRIPT_EOF'
          // .github/scripts/llm-accessibility-fixer.js
          import fs from 'fs/promises';
          import { Client } from '@modelcontextprotocol/sdk/client/index.js';
          import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
          import OpenAI from 'openai';

          class A11yMCPClient {
            constructor() {
              this.client = null;
              this.transport = null;
              this.isConnected = false;
            }

            async initialize() {
              console.log('üîß Initializing A11y MCP Server...');
              
              try {
                this.transport = new StdioClientTransport({
                  command: 'npx',
                  args: ['-y', 'a11y-mcp-server'],
                  env: process.env
                });

                this.client = new Client({
                  name: "llm-accessibility-fixer",
                  version: "1.0.0"
                }, {
                  capabilities: {
                    tools: {}
                  }
                });

                await this.client.connect(this.transport);
                console.log('‚úÖ A11y MCP Server connected');
                this.isConnected = true;
                
              } catch (error) {
                console.error('‚ùå Failed to initialize A11y MCP Server:', error.message);
                this.isConnected = false;
                // Don't throw - continue with LLM-only mode
              }
            }

            async testHtml(html, tags = ['wcag2aa']) {
              if (!this.isConnected) {
                console.log('‚ö†Ô∏è MCP not connected, using LLM-only analysis');
                return null;
              }

              try {
                const result = await this.client.callTool({
                  name: 'test_html_string',
                  arguments: { html: html, tags: tags }
                });
                
                if (result.content && result.content[0]?.text) {
                  return JSON.parse(result.content[0].text);
                }
                return null;
              } catch (error) {
                console.log(`‚ö†Ô∏è A11y MCP test failed: ${error.message}`);
                return null;
              }
            }

            async checkColorContrast(foreground, background) {
              if (!this.isConnected) {
                return this.calculateContrastRatio(foreground, background);
              }

              try {
                const result = await this.client.callTool({
                  name: 'check_color_contrast',
                  arguments: { foreground, background }
                });
                
                if (result.content && result.content[0]?.text) {
                  return JSON.parse(result.content[0].text);
                }
                
                return this.calculateContrastRatio(foreground, background);
              } catch (error) {
                return this.calculateContrastRatio(foreground, background);
              }
            }

            calculateContrastRatio(color1, color2) {
              const getLuminance = (color) => {
                try {
                  const hex = color.replace('#', '');
                  const r = parseInt(hex.substr(0, 2), 16) / 255;
                  const g = parseInt(hex.substr(2, 2), 16) / 255;
                  const b = parseInt(hex.substr(4, 2), 16) / 255;
                  
                  const [rs, gs, bs] = [r, g, b].map(c => 
                    c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
                  );
                  
                  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
                } catch (error) {
                  return 0.5;
                }
              };

              try {
                const lum1 = getLuminance(color1);
                const lum2 = getLuminance(color2);
                const brightest = Math.max(lum1, lum2);
                const darkest = Math.min(lum1, lum2);
                const ratio = (brightest + 0.05) / (darkest + 0.05);
                
                return {
                  contrastRatio: ratio,
                  passes: ratio >= 4.5,
                  wcagAA: ratio >= 4.5,
                  wcagAAA: ratio >= 7.0
                };
              } catch (error) {
                return { contrastRatio: 1, passes: false, wcagAA: false, wcagAAA: false };
              }
            }

            async disconnect() {
              if (this.client && this.isConnected) {
                try {
                  await this.client.close();
                  console.log('üîå Disconnected from A11y MCP Server');
                } catch (error) {
                  console.log('‚ö†Ô∏è Error disconnecting:', error.message);
                }
              }
            }
          }

          class LLMAccessibilityAgent {
            constructor(a11yClient) {
              this.a11yClient = a11yClient;
              this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
            }

            async analyzeAndFixAccessibility(htmlContent, filePath) {
              console.log('ü§ñ Starting LLM-powered accessibility analysis...');

              let initialAnalysis = null;
              try {
                initialAnalysis = await this.a11yClient.testHtml(htmlContent);
              } catch (error) {
                console.log('‚ö†Ô∏è MCP analysis failed, using LLM-only approach');
              }
              
              const fixPlan = await this.generateFixPlan(htmlContent, initialAnalysis, filePath);
              const fixedContent = await this.applyFixes(htmlContent, fixPlan);
              
              return {
                originalAnalysis: initialAnalysis,
                fixPlan: fixPlan,
                fixedContent: fixedContent
              };
            }

            async generateFixPlan(htmlContent, analysis, filePath) {
              console.log('üß† Generating fix plan with LLM...');

              const prompt = `Analyze this HTML for accessibility issues and provide specific fixes.

          FILE: ${filePath}

          HTML CONTENT:
          \`\`\`html
          ${htmlContent}
          \`\`\`

          Find accessibility issues like:
          1. Poor color contrast (suggest colors that pass WCAG AA 4.5:1 ratio)
          2. Missing alt text
          3. Unlabeled form inputs
          4. ARIA issues

          Return JSON:
          {
            "summary": "Brief overview",
            "fixes": [
              {
                "type": "color-contrast|alt-text|form|aria",
                "description": "What this fixes",
                "originalCode": "exact current code",
                "fixedCode": "exact replacement",
                "explanation": "why this works"
              }
            ]
          }`;

              try {
                const response = await this.openai.chat.completions.create({
                  model: "gpt-4",
                  messages: [
                    { role: "system", content: "You are an accessibility expert. Return only valid JSON." },
                    { role: "user", content: prompt }
                  ],
                  temperature: 0.1,
                  max_tokens: 3000
                });

                const responseText = response.choices[0].message.content;
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                
                if (jsonMatch) {
                  return JSON.parse(jsonMatch[0]);
                }
                
                return { summary: "No JSON found", fixes: [] };
              } catch (error) {
                console.error('‚ùå Error calling OpenAI:', error.message);
                return { summary: "OpenAI API error", fixes: [] };
              }
            }

            async applyFixes(htmlContent, fixPlan) {
              console.log('üîß Applying accessibility fixes...');

              let fixedContent = htmlContent;
              let appliedFixes = 0;

              for (const fix of fixPlan.fixes || []) {
                try {
                  if (fix.originalCode && fix.fixedCode && fixedContent.includes(fix.originalCode)) {
                    fixedContent = fixedContent.replace(fix.originalCode, fix.fixedCode);
                    appliedFixes++;
                    console.log(`‚úÖ Applied: ${fix.description}`);
                  }
                } catch (error) {
                  console.error(`‚ùå Error applying fix: ${error.message}`);
                }
              }

              console.log(`‚úÖ Applied ${appliedFixes} out of ${fixPlan.fixes?.length || 0} fixes`);
              return fixedContent;
            }

            async generateReport(results, filePath) {
              const fixesApplied = results.fixPlan?.fixes?.length || 0;

              return `# üéØ Accessibility Report

          **File:** ${filePath}  
          **Generated:** ${new Date().toISOString()}

          ## üìä Summary

          - Fixes Applied: ${fixesApplied}

          ## ‚úÖ Fixes Applied

          ${results.fixPlan?.fixes?.map((fix, i) => `${i + 1}. **${fix.type}**: ${fix.description}`).join('\n') || 'No fixes applied.'}

          ---
          *Generated by LLM + A11y MCP Server*`;
            }
          }

          async function findHtmlFiles() {
            const paths = ['index.html', 'public/index.html', 'src/index.html'];
            const found = [];
            
            for (const path of paths) {
              try {
                await fs.access(path);
                found.push(path);
                console.log(`‚úÖ Found: ${path}`);
              } catch (error) {
                // File doesn't exist
              }
            }
            
            return found;
          }

          async function main() {
            let a11yClient = null;
            
            try {
              console.log('üöÄ Starting accessibility fixing...');
              
              if (!process.env.OPENAI_API_KEY) {
                throw new Error('OPENAI_API_KEY required');
              }

              a11yClient = new A11yMCPClient();
              await a11yClient.initialize();

              const llmAgent = new LLMAccessibilityAgent(a11yClient);
              const htmlFiles = await findHtmlFiles();
              
              if (htmlFiles.length === 0) {
                console.log('‚ÑπÔ∏è No HTML files found');
                return;
              }

              let totalFixes = 0;

              for (const filePath of htmlFiles) {
                console.log(`\nüìÑ Processing ${filePath}...`);
                
                const originalContent = await fs.readFile(filePath, 'utf-8');
                const results = await llmAgent.analyzeAndFixAccessibility(originalContent, filePath);

                if (results.fixedContent !== originalContent) {
                  await fs.writeFile(`${filePath}.backup`, originalContent);
                  await fs.writeFile(filePath, results.fixedContent);
                  totalFixes += results.fixPlan.fixes?.length || 0;
                  console.log(`‚úÖ Applied fixes to ${filePath}`);
                }

                const report = await llmAgent.generateReport(results, filePath);
                await fs.writeFile(`ACCESSIBILITY_REPORT_${filePath.replace(/[\/\\]/g, '_')}.md`, report);
              }

              console.log(`üéâ Completed! Applied ${totalFixes} total fixes.`);

            } catch (error) {
              console.error('üí• Error:', error.message);
              process.exit(1);
            } finally {
              if (a11yClient) {
                await a11yClient.disconnect();
              }
            }
          }

          main();
          SCRIPT_EOF

      - name: Run LLM accessibility fixer
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          echo "ü§ñ Starting LLM-powered accessibility fixes..."
          
          # Create scripts directory
          mkdir -p .github/scripts
          
          # Run the fixer script
          node .github/scripts/llm-accessibility-fixer.js

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è No changes detected"
          else
            echo "changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Changes detected"
            
            # Count changed files
            CHANGED_FILES=$(git diff --name-only | grep -c '\.html$' || echo "0")
            echo "html_files_changed=$CHANGED_FILES" >> $GITHUB_OUTPUT
            
            # Show what changed
            echo "Changed files:"
            git diff --name-only
          fi

      - name: Validate HTML after fixes
        if: steps.changes.outputs.changed == 'true'
        run: |
          echo "üîç Validating HTML after fixes..."
          
          find . -name "*.html" -not -path "./.git/*" -not -path "./node_modules/*" | while read file; do
            echo "Checking: $file"
            
            # Basic validation - ensure file is valid HTML
            if ! grep -q "<!DOCTYPE" "$file"; then
              echo "‚ö†Ô∏è Warning: $file missing DOCTYPE"
            fi
            
            # Check for improvements
            ALT_COUNT=$(grep -c 'alt=' "$file" || echo "0")
            echo "‚úÖ $file has $ALT_COUNT alt attributes"
          done

      - name: Commit changes
        if: steps.changes.outputs.changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "LLM Accessibility Bot"
          
          git add .
          
          git commit -m "ü§ñ Apply LLM-powered accessibility fixes

          - Fixed color contrast issues
          - Added missing alt text
          - Improved WCAG compliance
          - Files modified: ${{ steps.changes.outputs.html_files_changed }}
          
          Generated by: LLM + A11y MCP Server
          Trigger: ${{ github.event_name }}
          
          [accessibility] [automated]"
          
          git push

      - name: Create job summary
        if: always()
        run: |
          echo "## ü§ñ LLM Accessibility Fixes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Repository:** \`${{ github.repository }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.changes.outputs.changed }}" == "true" ]; then
            echo "‚úÖ **Status:** Accessibility fixes applied successfully" >> $GITHUB_STEP_SUMMARY
            echo "- HTML files modified: ${{ steps.changes.outputs.html_files_changed }}" >> $GITHUB_STEP_SUMMARY
            
            if [ -f ACCESSIBILITY_SUMMARY.md ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### üìä Summary" >> $GITHUB_STEP_SUMMARY
              head -20 ACCESSIBILITY_SUMMARY.md >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ÑπÔ∏è **Status:** No accessibility issues found - site is already accessible!" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Powered by LLM + [A11y MCP Server](https://github.com/ronantakizawa/a11ymcp)*" >> $GITHUB_STEP_SUMMARY

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: accessibility-reports-${{ github.run_number }}
          path: |
            ACCESSIBILITY_*.md
            *.html.original
          retention-days: 30